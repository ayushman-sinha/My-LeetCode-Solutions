{"id":579108305,"lang":"cpp","time":"3 weeks, 1 day","timestamp":1635529567,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/579108305/","is_pending":"Not Pending","title":"Rotting Oranges","memory":"13.1 MB","code":"class Solution {\npublic:    \n        int orangesRotting(vector<vector<int>>& grid) {\n           queue<pair<int,int>>q;// queue to store rowXcolumn of rotten oranges\n          int fresh=0;//stores the number of fresh oranges\n            for(int i=0;i<grid.size();i++)\n            {\n                for(int j=0;j<grid[i].size();j++)\n                {\n                    if(grid[i][j]==2)\n                    {\n                        q.push({i,j});\n                        \n                    }\n                     if(grid[i][j]==1)                    \n                         fresh++;\n                     \n                }\n            }\n            int c=0;\n            /*Performing Breadth FIrst Search in all four Directions of rotten oranges if it contains a FRESH orange\n            THe boolean f is to ensure whether a fresh orange is encountered in any one side.\n            Also the number of fresh oranges are kept decreasing as each of them are turning rotten*/\n            while(!q.empty())\n            {\n             int siz=q.size(); bool f=false;\n                while(siz--)\n                {\n                int a=q.front().first;\n                int b=q.front().second;\n                q.pop();\n               //After an orange is ROTTEN we push it into our queue\n                if(a>0&&grid[a-1][b]==1)\n                {\n                    grid[a-1][b]=2;\n                    q.push({a-1,b});\n                   f=true;\n                    fresh--;\n                   \n                }\n                if(a<grid.size()-1&&grid[a+1][b]==1)\n                {\n                    grid[a+1][b]=2;\n                    q.push({a+1,b});\n                   f=true;\n                     fresh--;\n                   \n                }\n                  if(b>0&&grid[a][b-1]==1)\n                {\n                    grid[a][b-1]=2;\n                    q.push({a,b-1});\n                   f=true;\n                     fresh--;\n                }\n                 if(b<grid[0].size()-1&&grid[a][b+1]==1)\n                {\n                    grid[a][b+1]=2;\n                    q.push({a,b+1});\n                  f=true;\n                    fresh--; \n                }\n                    //c=f?c+1:c;\n                }\n                \n             if(f)//If a fresh orange is encountered in even one side of the rotten orange we increment our counter which is the time taken\n               c++;\n            }\n           // cout<<c<<\" \"<<rot<<\"\\n\";\n          if(fresh!=0)//if any fresh oranges remain we return -1\n              return -1;\n           \n            return c;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"rotting-oranges"}